package org.cf.smalivm.type;

import org.cf.smalivm.dex.CommonTypes;
import org.cf.util.ClassNameUtils;
import org.jf.dexlib2.iface.reference.TypeReference;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/*
 * Arrays have a clone method and a length field. They're both generated by Java on-demand.
 * https://stackoverflow.com/questions/38223880/how-did-jvm-implement-arrays-class
 */
public class VirtualArray extends VirtualGeneric {

    private final int dimensionRank;
    private Set<VirtualGeneric> ancestors;
    private Map<String, VirtualArrayMethod> methodDescriptorToMethod;

    VirtualArray(TypeReference typeReference) {
        super(typeReference, typeReference.getType(), ClassNameUtils.internalToBinary(typeReference.getType()),
                ClassNameUtils.internalToSource(typeReference.getType()));
        dimensionRank = ClassNameUtils.getDimensionCount(typeReference.getType());
    }

    private static String buildRankString(int rank) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < rank; i++) {
            sb.append('[');
        }

        return sb.toString();
    }

    @Override
    public Set<? extends VirtualGeneric> getAncestors() {
        if (ancestors != null) {
            return ancestors;
        }
        ancestors = new LinkedHashSet<>();

        TypeReference typeReference = getTypeReference();
        String baseType = ClassNameUtils.getComponentBase(typeReference.getType());
        if (!ClassNameUtils.isPrimitive(baseType)) {
            // It's an array of object type, so get ancestry for that object
            // Primitives have no ancestors. They're primordial. THEY ARE ETERNAL. ALL ONE OR NONE!
            ClassManager classManager = getClassManager();
            VirtualClass baseClass = classManager.getVirtualClass(baseType);
            String rankString = buildRankString(dimensionRank);

            // All ancestors of the base type with the same dimension rank
            for (VirtualClass baseAncestor : baseClass.getAncestors()) {
                String ancestorName = rankString + baseAncestor.getTypeReference().getType();
                VirtualArray ancestor = (VirtualArray) classManager.getVirtualType(ancestorName);
                ancestors.add(ancestor);
            }
        }
        // All arrays are an instance of an Object
        // http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.3.1
        // Also, [[[String is an instance of [[Object and [Object
        for (int i = dimensionRank - 1; i >= 0; i--) {
            String objectType = buildRankString(i) + CommonTypes.OBJECT;
            VirtualGeneric ancestor = classManager.getVirtualType(objectType);
            ancestors.add(ancestor);
        }

        return ancestors;
    }

    @Override
    public VirtualField getField(String fieldName) {
        return null;
    }

    @Override
    public Collection<VirtualField> getFields() {
        // someArray[].length is actually handled by array-length op
        return Collections.emptyList();
    }

    @Override
    public VirtualMethod getMethod(String methodDescriptor) {
        VirtualMethod method = getMethod0(methodDescriptor);
        if (method != null) {
            return method;
        }
        for (VirtualGeneric ancestor : getAncestors()) {
            if (ancestor instanceof VirtualArray) {
                method = ((VirtualArray) ancestor).getMethod0(methodDescriptor);
                if (method != null) {
                    return method;
                }
            }
        }

        return null;
    }

    @Override
    public Collection<VirtualMethod> getMethods() {
        if (methodDescriptorToMethod == null) {
            methodDescriptorToMethod = buildMethodsMap();
        }
        List<VirtualMethod> methods = new LinkedList<>();
        methods.addAll(methodDescriptorToMethod.values());

        return methods;
    }

    @Override
    public boolean instanceOf(VirtualGeneric targetType) {
        if (equals(targetType)) {
            return true;
        }
        for (VirtualGeneric ancestor : getAncestors()) {
            if (ancestor.equals(targetType)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean isArray() {
        return true;
    }

    @Override
    public boolean isPrimitive() {
        return false;
    }

    public VirtualGeneric getBaseType() {
        String baseType = ClassNameUtils.getComponentBase(getName());

        return classManager.getVirtualType(baseType);
    }

    public VirtualGeneric getComponentType() {
        String componentType = ClassNameUtils.getComponentType(getName());

        return classManager.getVirtualType(componentType);
    }

    private VirtualArrayMethod getMethod0(String methodDescriptor) {
        if (methodDescriptorToMethod == null) {
            methodDescriptorToMethod = buildMethodsMap();
        }

        return methodDescriptorToMethod.get(methodDescriptor);
    }

    private Map<String, VirtualArrayMethod> buildMethodsMap() {
        Map<String, VirtualArrayMethod> methods = new HashMap<>(2);
        String methodDescriptor = "clone()Ljava/lang/Object;";
        String methodSignature = getName() + "->" + methodDescriptor;
        TypeReference reference = classManager.getFrameworkDexBuilder().internTypeReference(methodSignature);

        VirtualArrayMethod method = new VirtualArrayMethod(reference, this);
        methods.put(methodDescriptor, method);

        return methods;
    }

}
